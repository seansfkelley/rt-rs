use std::ops::{Add, Sub, Div, Mul, Neg};
use vector::Vec3;

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Mat4 {
    pub cells: [[f64; 4]; 4],
}

pub const IDENTITY: Mat4 = Mat4 {
    cells: [
        [1f64, 0f64, 0f64, 0f64],
        [0f64, 1f64, 0f64, 0f64],
        [0f64, 0f64, 1f64, 0f64],
        [0f64, 0f64, 0f64, 1f64],
    ],
};

impl Mat4 {
    pub fn create() -> Mat4 {
        Mat4 { cells: [[0f64; 4]; 4] }
    }

    //    pub fn rotate(&self, theta: f64) -> Mat4 {
    //
    //    }

    pub fn get_cell(&self, x: usize, y: usize) -> f64 {
        self.cells[y][x]
    }

    // https://stackoverflow.com/questions/1148309/inverting-a-4x4-matrix
    pub fn invert(&self) -> Option<Mat4> {
        let mut inverse = [[0f64; 4]; 4];
        let m = self.cells;

        inverse[0][0] = m[1][1] * m[2][2] * m[3][3] -
            m[1][1] * m[3][2] * m[2][3] -
            m[1][2] * m[2][1] * m[3][3] +
            m[1][2] * m[3][1] * m[2][3] +
            m[1][3] * m[2][1] * m[3][2] -
            m[1][3] * m[3][1] * m[2][2];

        inverse[0][1] = -m[0][1] * m[2][2] * m[3][3] +
            m[0][1] * m[3][2] * m[2][3] +
            m[0][2] * m[2][1] * m[3][3] -
            m[0][2] * m[3][1] * m[2][3] -
            m[0][3] * m[2][1] * m[3][2] +
            m[0][3] * m[3][1] * m[2][2];

        inverse[0][2] = m[0][1] * m[1][2] * m[3][3] -
            m[0][1] * m[3][2] * m[1][3] -
            m[0][2] * m[1][1] * m[3][3] +
            m[0][2] * m[3][1] * m[1][3] +
            m[0][3] * m[1][1] * m[3][2] -
            m[0][3] * m[3][1] * m[1][2];

        inverse[0][3] = -m[0][1] * m[1][2] * m[2][3] +
            m[0][1] * m[2][2] * m[1][3] +
            m[0][2] * m[1][1] * m[2][3] -
            m[0][2] * m[2][1] * m[1][3] -
            m[0][3] * m[1][1] * m[2][2] +
            m[0][3] * m[2][1] * m[1][2];

        inverse[1][0] = -m[1][0] * m[2][2] * m[3][3] +
            m[1][0] * m[3][2] * m[2][3] +
            m[1][2] * m[2][0] * m[3][3] -
            m[1][2] * m[3][0] * m[2][3] -
            m[1][3] * m[2][0] * m[3][2] +
            m[1][3] * m[3][0] * m[2][2];

        inverse[1][1] = m[0][0] * m[2][2] * m[3][3] -
            m[0][0] * m[3][2] * m[2][3] -
            m[0][2] * m[2][0] * m[3][3] +
            m[0][2] * m[3][0] * m[2][3] +
            m[0][3] * m[2][0] * m[3][2] -
            m[0][3] * m[3][0] * m[2][2];

        inverse[1][2] = -m[0][0] * m[1][2] * m[3][3] +
            m[0][0] * m[3][2] * m[1][3] +
            m[0][2] * m[1][0] * m[3][3] -
            m[0][2] * m[3][0] * m[1][3] -
            m[0][3] * m[1][0] * m[3][2] +
            m[0][3] * m[3][0] * m[1][2];

        inverse[1][3] = m[0][0] * m[1][2] * m[2][3] -
            m[0][0] * m[2][2] * m[1][3] -
            m[0][2] * m[1][0] * m[2][3] +
            m[0][2] * m[2][0] * m[1][3] +
            m[0][3] * m[1][0] * m[2][2] -
            m[0][3] * m[2][0] * m[1][2];

        inverse[2][0] = m[1][0] * m[2][1] * m[3][3] -
            m[1][0] * m[3][1] * m[2][3] -
            m[1][1] * m[2][0] * m[3][3] +
            m[1][1] * m[3][0] * m[2][3] +
            m[1][3] * m[2][0] * m[3][1] -
            m[1][3] * m[3][0] * m[2][1];

        inverse[2][1] = -m[0][0] * m[2][1] * m[3][3] +
            m[0][0] * m[3][1] * m[2][3] +
            m[0][1] * m[2][0] * m[3][3] -
            m[0][1] * m[3][0] * m[2][3] -
            m[0][3] * m[2][0] * m[3][1] +
            m[0][3] * m[3][0] * m[2][1];

        inverse[2][2] = m[0][0] * m[1][1] * m[3][3] -
            m[0][0] * m[3][1] * m[1][3] -
            m[0][1] * m[1][0] * m[3][3] +
            m[0][1] * m[3][0] * m[1][3] +
            m[0][3] * m[1][0] * m[3][1] -
            m[0][3] * m[3][0] * m[1][1];

        inverse[2][3] = -m[0][0] * m[1][1] * m[2][3] +
            m[0][0] * m[2][1] * m[1][3] +
            m[0][1] * m[1][0] * m[2][3] -
            m[0][1] * m[2][0] * m[1][3] -
            m[0][3] * m[1][0] * m[2][1] +
            m[0][3] * m[2][0] * m[1][1];

        inverse[3][0] = -m[1][0] * m[2][1] * m[3][2] +
            m[1][0] * m[3][1] * m[2][2] +
            m[1][1] * m[2][0] * m[3][2] -
            m[1][1] * m[3][0] * m[2][2] -
            m[1][2] * m[2][0] * m[3][1] +
            m[1][2] * m[3][0] * m[2][1];

        inverse[3][1] = m[0][0] * m[2][1] * m[3][2] -
            m[0][0] * m[3][1] * m[2][2] -
            m[0][1] * m[2][0] * m[3][2] +
            m[0][1] * m[3][0] * m[2][2] +
            m[0][2] * m[2][0] * m[3][1] -
            m[0][2] * m[3][0] * m[2][1];

        inverse[3][2] = -m[0][0] * m[1][1] * m[3][2] +
            m[0][0] * m[3][1] * m[1][2] +
            m[0][1] * m[1][0] * m[3][2] -
            m[0][1] * m[3][0] * m[1][2] -
            m[0][2] * m[1][0] * m[3][1] +
            m[0][2] * m[3][0] * m[1][1];

        inverse[3][3] = m[0][0] * m[1][1] * m[2][2] -
            m[0][0] * m[2][1] * m[1][2] -
            m[0][1] * m[1][0] * m[2][2] +
            m[0][1] * m[2][0] * m[1][2] +
            m[0][2] * m[1][0] * m[2][1] -
            m[0][2] * m[2][0] * m[1][1];

        let determinant = m[0][0] * inverse[0][0] + m[1][0] * inverse[0][1] + m[2][0] * inverse[0][2] + m[3][0] * inverse[0][3];

        if determinant == 0f64 {
            None
        } else {
            for x in 0..4 {
                for y in 0..4 {
                    inverse[y][x] = inverse[y][x] / determinant;
                }
            }

            Some(Mat4 {
                cells: inverse
            })
        }
    }
}

impl Mul for Mat4 {
    type Output = Mat4;

    fn mul(self, other: Mat4) -> Mat4 {
        let mut cells = [[0f64; 4]; 4];
        for x in 0..4 {
            for y in 0..4 {
                for i in 0..4 {
                    cells[y][x] += self.get_cell(i, y) * other.get_cell(x, i);
                }
            }
        }

        Mat4 { cells }
    }
}

impl Mul<Vec3> for Mat4 {
    type Output = Vec3;

    fn mul(self, other: Vec3) -> Vec3 {
        let mut vec4 = [0f64; 4];

        for i in 0..4 {
            vec4[i] = self.get_cell(0, i) * other.x
                + self.get_cell(1, i) * other.y
                + self.get_cell(2, i) * other.z
                + self.get_cell(3, i);
        }

        Vec3 {
            x: vec4[0],
            y: vec4[1],
            z: vec4[2],
        }
    }
}
