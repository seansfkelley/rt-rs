use std::str::FromStr;
use std::boxed::Box;
use std::rc::Rc;
use std::path::{ Path, PathBuf };
use math::*;
use core::*;
use geometry::*;
use importer::scene_builder::SceneBuilder;
use color::{ Color, BLACK, WHITE };

grammar(builder: &mut SceneBuilder);

pub SceneFile: () = {
    Statement* => {},
};

Statement: () = {
    "camera" <Camera> => builder.camera(<>),
    "image_dimensions" <Tuple2<U32, U32>> => builder.image_dimensions(<>),
    "antialias" <U32> => builder.antialias(<>),
    "depth_limit" <U32> => builder.depth_limit(<>),
    "background_color" <Color> => builder.background_color(<>),
    "material" <Identifier> <Material> => builder.register_material(<>),
    "transform" "pop" <U32?> => builder.pop_transforms(<>.unwrap_or(1u32)),
    "transform" <Transform> => builder.push_transform(<>),
    "object" <Object> => builder.add_object(<>),
    "light" <Light> => builder.add_light(<>),
};

Material: Box<Material> = {
    "flat" "{"
        "color" <color:Color>
        <specular_exponent:("specular_exponent" <F64>)?>
        <reflectivity:("reflectivity" <F64>)?>
    "}" => Box::new(ReflectiveMaterial::new(
        color * 0.1f64,
        color,
        SpecularLighting(color * 0.5f64, specular_exponent.unwrap_or(0f64)),
        ReflectiveLighting(WHITE, reflectivity.unwrap_or(0f64)),
    )),
    "image" "{"
        "path" <path:Path>
        <reflectivity:("reflectivity" <F64>)?>
    "}" => Box::new(ImageTextureMaterial::from_path(path.as_ref(), reflectivity.unwrap_or(0f64))),
    "checkerboard" "{"
        <checks_per_unit:("checks_per_unit" <U32>)?>
        <color_a:("color_a" <Color>)?>
        <color_b:("color_b" <Color>)?>
    "}" => Box::new(CheckerboardMaterial {
        checks_per_unit: checks_per_unit.unwrap_or(2u32),
        color_a: color_a.unwrap_or(WHITE),
        color_b: color_b.unwrap_or(BLACK),
    }),
};

Transform: Mat4 = {
    "scale" <Vec3> => Mat4::create_scale(&<>),
    "translate" <Vec3> => Mat4::create_translation(&<>),
    "rotate" <theta_degrees:F64> <axis:Vec3> => Mat4::create_rotation(theta_degrees.to_radians(), &axis),
};

Object = "{"
    "geometry" <Geometry>
    "material" <Identifier>
"}";

Camera: Camera = "{"
    "position" <position:Point>
    "up" <up:Vec3>
    "look_at" <look_at:Point>
"}" => Camera::look_at(position, up, look_at);

Geometry: Box<Geometry> = {
    "sphere" "{"
        "radius" <F64>
    "}" => Box::new(Sphere::new(<>)),
    "triangle_mesh" "{"
        "positions" <positions:List<Point>>
        <normals:("normals" <List<Normal>>)?>
        <uvs:("uvs" <List<Tuple2<F64, F64>>>)?>
        "indices" <indices:List<Tuple3<Usize, Usize, Usize>>>
    "}" => Box::new(TriangleMesh::new(
        positions,
        normals.unwrap_or(vec![]),
        uvs.unwrap_or(vec![]),
        indices,
    )),
    "difference" "{"
        "positive" "{"
            "geometry" <positive_geometry:Geometry>
            <positive_transform:("transform" <Transform>)?>
        "}"
        "negative" "{"
            "geometry" <negative_geometry:Geometry>
            <negative_transform:("transform" <Transform>)?>
        "}"
    "}" => Box::new(Difference::new(
        Rc::new(Shape::new(Rc::from(positive_geometry), positive_transform.map(Transform::new).unwrap_or(IDENTITY_TRANSFORM))),
        Rc::new(Shape::new(Rc::from(negative_geometry), negative_transform.map(Transform::new).unwrap_or(IDENTITY_TRANSFORM))),
    )),
};

Light: Light = "{"
    "position" <position:Point>
    "color" <color:Color>
"}" => Light { position, color };

// Handily adapted from the tutorial!
// https://github.com/nikomatsakis/lalrpop/blob/master/doc/tutorial.md
List<T>: Vec<T> = {
    "[" <v:(<T> ",")*> <e:T?> "]" => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Tuple2<T1, T2>: (T1, T2) = <T1> <T2>;
Tuple3<T1, T2, T3>: (T1, T2, T3) = <T1> <T2> <T3>;

Point: Point = <f1:F64> <f2:F64> <f3:F64> => Point { x: f1, y: f2, z: f3 };
Vec3: Vec3 = <f1:F64> <f2:F64> <f3:F64> => Vec3 { x: f1, y: f2, z: f3 };
Normal: Normal = <f1:F64> <f2:F64> <f3:F64> => Normal { x: f1, y: f2, z: f3 };
Color: Color = <f1:F64> <f2:F64> <f3:F64> => Color { r: f1, g: f2, b: f3 };

Identifier = r"[a-zA-Z_][a-zA-Z0-9_]*";
Path: Box<Path> = r#""[-a-zA-Z0-9./]+""# => PathBuf::from(<>[1..<>.len() - 1].to_owned()).into_boxed_path();
RawNumber = r"[-+]?[0-9]*\.?[0-9]+"; // Ripped from https://www.regular-expressions.info/floatingpoint.html
F64: f64 = RawNumber => f64::from_str(<>).unwrap();
U32: u32 = RawNumber => u32::from_str(<>).unwrap();
Usize: usize = RawNumber => usize::from_str(<>).unwrap();
