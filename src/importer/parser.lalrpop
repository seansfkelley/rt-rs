use std::str::FromStr;
use std::boxed::Box;
use std::rc::Rc;
use std::path::{ Path, PathBuf };
use math::*;
use core::*;
use geometry::*;
use importer::scene_builder::*;
use color::{ Color, BLACK, WHITE };

grammar(builder: &mut SceneBuilder);

pub SceneFile: () = {
    Statement* => {},
};

Statement: () = {
    "camera" <CameraBuilder> => builder.camera(<>),
    "animation" <Animation> => builder.animation(<>),
    "image_dimensions" <Tuple2<U32, U32>> => builder.image_dimensions(<>),
    "antialias" <U32> => builder.antialias(<>),
    "depth_limit" <U32> => builder.depth_limit(<>),
    "background_color" <Color> => builder.background_color(<>),
    "texture" <Identifier> <Texture> => builder.register_texture(<>),
    "transform" "pop" "all" => builder.pop_all_transforms(),
    "transform" "pop" <U32?> => builder.pop_n_transforms(<>.unwrap_or(1u32)),
    "transform" <Transform> => builder.push_transform(<>),
    "object" <Object> => builder.add_object(<>),
    "light" <Light> => builder.add_light(<>),
};

CameraBuilder: CameraBuilder = {
    "orthographic" "{"
        <common:CameraCommon>
    "}" => CameraBuilder::Orthographic(common),
    "perspective" "{"
        <common:CameraCommon>
        <fov:("field_of_view" <F64>)?>
    "}" => CameraBuilder::Perspective(common, fov.unwrap_or(90f64)),
};

CameraCommon: CameraCommon = {
    "position" <Point>
    "look_at" <Point>
    "up" <Vec3>
    <("screen_size" <Tuple2<F64, F64>>)?>
};

Animation: (u32, Vec<Mat4>) = "{"
    "frames" <U32>
    "camera_transforms" <List<Transform>>
"}";

Material: Material = {
    "flat" "{"
        "color" <color:Color>
        <specular_exponent:("specular_exponent" <F64>)?>
        <reflectivity_option:("reflectivity" <F64>)?>
    "}" => Material {
        ambient: color * 0.1f64,
        diffuse: color,
        specular: SpecularLighting(color * 0.5f64, specular_exponent.unwrap_or(0f64)),
        transmission: None,
        reflectivity: reflectivity_option.unwrap_or(0f64),
    },
    "transmissive" "{"
        "color" <color:Color>
        "specular_exponent" <specular_exponent:F64>
        "index_of_refraction" <index_of_refraction:F64>
        "transmissivity" <transmissivity:F64>
        "reflectivity" <reflectivity:F64>
    "}" => Material {
        ambient: color * 0.1f64,
        diffuse: color,
        specular: SpecularLighting(color * 0.5f64, specular_exponent),
        transmission: Some(Transmission { transmissivity, index_of_refraction }),
        reflectivity,
    },
};

Texture: Box<Texture> = {
    "constant" <Material> => Box::new(ConstantTexture { material: <> }),
    "image" "{"
        "path" <path:Path>
        <reflectivity:("reflectivity" <F64>)?>
    "}" => Box::new(ImageTexture::from_path(path.as_ref(), reflectivity.unwrap_or(0f64))),
    "checkerboard" "{"
        <checks_per_unit:("checks_per_unit" <U32>)?>
        <color_a:("color_a" <Color>)?>
        <color_b:("color_b" <Color>)?>
    "}" => Box::new(CheckerboardTexture {
        checks_per_unit: checks_per_unit.unwrap_or(2u32),
        color_a: color_a.unwrap_or(WHITE),
        color_b: color_b.unwrap_or(BLACK),
    }),
};


Transform: Mat4 = {
    "scale" <Vec3> => Mat4::create_scale(<>),
    "translate" <Vec3> => Mat4::create_translation(<>),
    "rotate" <theta_degrees:F64> <axis:Vec3> => Mat4::create_rotation(theta_degrees.to_radians(), axis.as_normalized()),
};

Object = "{"
    "geometry" <Geometry>
    "texture" <Identifier>
"}";

Geometry: Box<Geometry> = {
    "sphere" "{"
        "radius" <F64>
    "}" => Box::new(Sphere::new(<>)),
    "rect_prism" "{"
        "min" <min:Point>
        "max" <max:Point>
    "}" => Box::new(RectPrism::new(min, max)),
    "triangle_mesh" "{"
        "positions" <positions:List<Point>>
        <normals:("normals" <List<Normal>>)?>
        <uvs:("uvs" <List<Tuple2<F64, F64>>>)?>
        "indices" <indices:List<Tuple3<Usize, Usize, Usize>>>
        <is_closed:("is_closed" <Bool>)?>
    "}" => Box::new(TriangleMesh::new(
        positions,
        normals.map(|ns| ns.iter().map(|n| n.as_normalized()).collect()),
        uvs,
        indices,
        is_closed.unwrap_or(true),
    )),
    "difference" "{"
        "positive" "{"
            "geometry" <positive_geometry:Geometry>
            <positive_transform:("transform" <Transform>)?>
        "}"
        "negative" "{"
            "geometry" <negative_geometry:Geometry>
            <negative_transform:("transform" <Transform>)?>
        "}"
    "}" => Box::new(Difference::new(
        Rc::new(Shape::new(Rc::from(positive_geometry), positive_transform.map(Transform::new).unwrap_or(IDENTITY_TRANSFORM))),
        Rc::new(Shape::new(Rc::from(negative_geometry), negative_transform.map(Transform::new).unwrap_or(IDENTITY_TRANSFORM))),
    )),
    "cloth" "{"
        "curves" <curves:List<Curve>>
        <tessellation_factor:("tessellation_factor" <Usize>)?>
    "}" => Box::new(create_cloth(
        curves,
        tessellation_factor.unwrap_or(100usize),
    )),

};

Light: Light = "{"
    "position" <position:Point>
    "color" <color:Color>
"}" => Light { position, color };

// Handily adapted from the tutorial!
// https://github.com/nikomatsakis/lalrpop/blob/master/doc/tutorial.md
List<T>: Vec<T> = {
    "[" <v:(<T> ",")*> <e:T?> "]" => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Tuple2<T1, T2>: (T1, T2) = <T1> <T2>;
Tuple3<T1, T2, T3>: (T1, T2, T3) = <T1> <T2> <T3>;

Point: Point = <f1:F64> <f2:F64> <f3:F64> => Point { x: f1, y: f2, z: f3 };
Vec3: Vec3 = <f1:F64> <f2:F64> <f3:F64> => Vec3 { x: f1, y: f2, z: f3 };
Normal: Normal = <f1:F64> <f2:F64> <f3:F64> => Normal { x: f1, y: f2, z: f3 };
Color: Color = {
    <f1:F64> <f2:F64> <f3:F64> => Color { r: f1, g: f2, b: f3 },
    r##"#[0-9a-fA-F]{3}"## => Color {
        r: u32::from_str_radix(&<>[1..2], 16).unwrap() as f64 / 15f64,
        g: u32::from_str_radix(&<>[2..3], 16).unwrap() as f64 / 15f64,
        b: u32::from_str_radix(&<>[3..4], 16).unwrap() as f64 / 15f64,
    },
    r##"#[0-9a-fA-F]{6}"## => Color {
        r: u32::from_str_radix(&<>[1..3], 16).unwrap() as f64 / 255f64,
        g: u32::from_str_radix(&<>[3..5], 16).unwrap() as f64 / 255f64,
        b: u32::from_str_radix(&<>[5..7], 16).unwrap() as f64 / 255f64,
    },
};

Curve: Box<Curve> = {
    "cubic_bezier" "{"
        "p0" <p0: Point>
        "p1" <p1: Point>
        "p2" <p2: Point>
        "p3" <p3: Point>
    "}" => Box::new(CubicBezier { p0, p1, p2, p3 }),
};

Bool: bool = {
    "true" => true,
    "false" => false,
};

Identifier = r"[a-zA-Z_][a-zA-Z0-9_]*";
Path: Box<Path> = r#""[-a-zA-Z0-9./_]+""# => PathBuf::from(<>[1..<>.len() - 1].to_owned()).into_boxed_path();
RawNumber = r"[-+]?[0-9]*\.?[0-9]+"; // Ripped from https://www.regular-expressions.info/floatingpoint.html
F64: f64 = RawNumber => f64::from_str(<>).unwrap();
U32: u32 = RawNumber => u32::from_str(<>).unwrap();
Usize: usize = RawNumber => usize::from_str(<>).unwrap();
