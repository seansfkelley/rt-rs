use std::str::FromStr;
use math::*;
use core::*;
use importer::scene_builder::SceneBuilder;

grammar(builder: &mut SceneBuilder);

match {
    // Ripped from https://www.regular-expressions.info/floatingpoint.html
    r"[-+]?[0-9]*\.?[0-9]+" => FLOAT,
} else {
    r"[0-9]+" => INTEGER,
    _,
}

pub SceneFile: () = {
    Statement* => {},
};

Statement: () = {
    "camera_position" <Point> => builder.camera_position(<>),
    "camera_up" <Vec3> => builder.camera_up(<>),
    "camera_look_at" <Point> => builder.camera_look_at(<>),
    "antialias" <Integer> => builder.antialias(<>),
    "material" <name:Identifier> <m:Material> => builder.register_material(name, m),
};

Material: Box<Material> = {
    "flat" "{"
        <color:KV<"color", Color>?>
        <specular_exponent:KV<"specular_exponent", Float>?>
        <reflectivity:KV<"reflectivity", Float>?>
    "}" => Box::new(FlatMaterial {
        color: color.unwrap_or(BLACK),
        specular_exponent: specular_exponent.unwrap_or(0f64),
        reflectivity: reflectivity.unwrap_or(0f64),
    }),
};

KV<K, V>: V = K <V>;

Point: Point = <f1:Float> <f2:Float> <f3:Float> => Point { x: f1, y: f2, z: f3 };
Vec3: Vec3 = <f1:Float> <f2:Float> <f3:Float> => Vec3 { x: f1, y: f2, z: f3 };
Color: Color = <f1:Float> <f2:Float> <f3:Float> => Color { r: f1, g: f2, b: f3 };

Identifier = r"[a-zA-Z0-9_]+";
Float: f64 = FLOAT => f64::from_str(<>).unwrap();
Integer: u32 = INTEGER => u32::from_str(<>).unwrap();
