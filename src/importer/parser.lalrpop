use std::str::FromStr;
use math::*;
use core::*;
use geometry::*;
use importer::scene_builder::SceneBuilder;

grammar(builder: &mut SceneBuilder);

pub SceneFile: () = {
    Statement* => {},
};

Statement: () = {
    "camera_position" <Point> => builder.camera_position(<>),
    "camera_up" <Vec3> => builder.camera_up(<>),
    "camera_look_at" <Point> => builder.camera_look_at(<>),
    "antialias" <Integer> => builder.antialias(<>),
    "material" <name:Identifier> <m:Material> => builder.register_material(name, m),
    "transform pop" => builder.pop_transform(),
    "transform" <Transform> => builder.push_transform(<>),
    "object" <o:Object> => builder.add_object(o.0, o.1),
};

Material: Box<Material> = {
    "flat" "{"
        <color:KV<"color", Color>?>
        <specular_exponent:KV<"specular_exponent", Float>?>
        <reflectivity:KV<"reflectivity", Float>?>
    "}" => Box::new(FlatMaterial {
        color: color.unwrap_or(BLACK),
        specular_exponent: specular_exponent.unwrap_or(0f64),
        reflectivity: reflectivity.unwrap_or(0f64),
    }),
    "checkerboard" "{"
        <checks_per_unit:KV<"checks_per_unit", Integer>?>
        <color_a:KV<"color_a", Color>?>
        <color_b:KV<"color_b", Color>?>
    "}" => Box::new(CheckerboardMaterial {
        checks_per_unit: checks_per_unit.unwrap_or(10u32),
        color_a: color_a.unwrap_or(WHITE),
        color_b: color_b.unwrap_or(BLACK),
    }),
};

Transform: Mat4 = {
    "scale" <Vec3> => Mat4::create_scale(<>),
    "translate" <Vec3> => Mat4::create_translation(<>),
    "rotate" <theta_degrees:Float> <axis:Vec3> => Mat4::create_rotation(theta_degrees.to_radians(), axis),
};

Object = "{" <KV<"geometry", Geometry>> <KV<"material", Identifier>> "}";

Geometry: Box<Geometry> = {
    "sphere" "{" <Float> "}" => Box::new(Sphere::new(<>)),
};

KV<K, V>: V = K <V>;

Point: Point = <f1:Float> <f2:Float> <f3:Float> => Point { x: f1, y: f2, z: f3 };
Vec3: Vec3 = <f1:Float> <f2:Float> <f3:Float> => Vec3 { x: f1, y: f2, z: f3 };
Color: Color = <f1:Float> <f2:Float> <f3:Float> => Color { r: f1, g: f2, b: f3 };

Identifier = r"[a-zA-Z_][a-zA-Z0-9_]*";
RawNumber = r"[-+]?[0-9]*\.?[0-9]+"; // Ripped from https://www.regular-expressions.info/floatingpoint.html
Float: f64 = RawNumber => f64::from_str(<>).unwrap();
Integer: u32 = RawNumber => u32::from_str(<>).unwrap();
